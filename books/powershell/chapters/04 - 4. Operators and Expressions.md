# 4. Operators and Expressions

PowerShell gives you two big building blocks: commands and expressions. Commands (cmdlets, functions, scripts, and native executables) do the heavy lifting; expressions evaluate to values. Operators are the glue that turns raw values into meaningful expressions—they combine, compare, transform, and route objects so that your pipelines do exactly what you intend.

Compared to many traditional shells, PowerShell’s operators are object‑aware and strongly typed. The same `+` symbol that adds integers can also concatenate strings or join arrays, and the same `-eq` equality operator works for numbers, strings, dates, and custom .NET types. The engine relies on the .NET type system to pick the right behavior rather than treating everything as plain text.

This chapter focuses on the operators that show up in almost every real script: arithmetic and assignment, comparison, boolean logic, redirection, and the subexpression operators that let you control evaluation. Later chapters build on these mechanics instead of re‑explaining them, so investing in a clear mental model here will pay off across the rest of the book.


## Prereqs

- Chapter 1 concepts: command syntax, parameters, and object-first shell usage
- Chapter 2 concepts: numeric/string types, casting, and variable scope basics
- Chapter 3 concepts: reading pipeline expressions in `Where-Object` and calculated properties
- A working PowerShell session (`powershell.exe` or `pwsh`) to run examples

## Learning Outcomes

- Evaluate arithmetic and assignment expressions and predict common type-promotion behavior
- Use comparison, membership, wildcard, and type operators correctly in conditions and filters
- Combine boolean operators with parentheses to control precedence and readability
- Apply bitwise, redirection, subexpression, and array-subexpression operators in practical scripts
- Build multi-operator expressions that remain readable in real-world PowerShell workflows

## Key Terms

expression, operator, operand, type promotion, precedence, associativity, comparison operator, wildcard matching, bitwise operator, redirection, subexpression, array subexpression

## Example Labels

- `<!-- Illustrative -->`: concept-focused examples that may need adaptation for your environment
- `<!-- Tested on: ... -->`: examples validated on a specific PowerShell/runtime version

<!-- Illustrative -->
```powershell
# A small expression that uses several operator families
(Get-Process pwsh).CPU / 60 -gt 5 -and $IsWindows
```

## 4.1 Arithmetic and Assignment

Arithmetic operators are the most familiar: they look like the math you already know. In PowerShell they are not limited to integers, though—you can use the same symbols with `double`, `decimal`, `TimeSpan`, and even some domain types that overload arithmetic (for example, adding `TimeSpan` values to a `DateTime`).

At the prompt PowerShell works perfectly well as a calculator, but the same expressions you try interactively are the ones you will later embed into scripts and functions. Understanding how types are chosen, how results are promoted, and how assignment interacts with those results will keep you from being surprised by edge cases.

<!-- Illustrative -->
```powershell
10 + 5           # 15
10 / 4           # 2.5 (Double)
(Get-Date) + (New-TimeSpan -Days 7)   # Date one week from now
```

### 4.1.1 Standard Math Operators (+, -, *, /, %)

PowerShell implements the usual arithmetic operators and gives them behavior that mostly matches other languages:

- `+` – addition, string concatenation, and array concatenation.
- `-` – subtraction and numeric negation.
- `*` – multiplication.
- `/` – division (returns a `double` by default).
- `%` – modulo (remainder after division).

Most of the time you simply rely on these operators and let PowerShell figure out the appropriate .NET numeric type. For example, dividing two integers (`10 / 4`) returns a `double` (`2.5`), because truncating the fractional part would silently lose information.

<!-- Illustrative -->
```powershell
1 + 2            # 3
1.5 + 2          # 3.5
"Hello, " + "world"    # "Hello, world"
1,2,3 + 4,5      # 1 2 3 4 5   (array concatenation)
10 / 4           # 2.5
10 % 4           # 2
```

#### 4.1.1.1 Type Promotion Rules

When you combine values of different numeric types, PowerShell follows a “widening” strategy: it prefers a result type that can represent both inputs without losing information. This behavior is implemented in the engine via .NET’s `LanguagePrimitives` helpers and the overloads available on the underlying types.

Some practical consequences:

- When you mix integers and floating‑point numbers, PowerShell promotes to the floating‑point type (typically `double`).
- When you mix `decimal` with `double`, the engine generally prefers `decimal` to preserve precision for financial calculations.
- When you combine different integer sizes (for example, `int` and `long`), the result is usually the larger integer type.

Type promotion is not the same as arbitrary‑precision math. PowerShell still uses the normal .NET numeric types; if you want to avoid overflow you should choose a sufficiently wide type up front (for example, `[int64]` or `[decimal]`).

**Int + Double = Double:** A very common promotion rule is integer plus floating‑point equals floating‑point. The integer is converted to a `double` and the calculation is performed in floating‑point space:

<!-- Illustrative -->
```powershell
$value = 10 + 2.5
$value
$value.GetType().Name
```

Output:

<!-- Illustrative -->
```text
12.5
Double
```

If both operands were integers, the result would still be widened to `double` when needed:

<!-- Illustrative -->
```powershell
(1 / 2).GetType().Name   # Double, not Int32
1 / 2                    # 0.5
```

This behavior matches the principle of “don’t silently throw away precision” unless you explicitly request integer division (for example by casting: `[int](1 / 2)`).

**Precision preservation logic:** Numeric literals in PowerShell are parsed into the smallest type that can hold them: small whole numbers become `Int32`, very large ones become `Int64` or `decimal`, and numbers with a decimal point become `double` unless you specify a suffix such as `d` (decimal). When you perform arithmetic, the engine:

- Chooses a result type that can represent both inputs.
- Avoids down‑converting to a smaller type unless you explicitly cast.
- Lets you opt into higher precision when needed.

<!-- Illustrative -->
```powershell
$int32   = 2147483647          # [int]
$int64   = 2147483648          # Parsed as [long]
$decimal = 10.1d               # [decimal]

($int32  + 1).GetType().Name   # Int64 (auto-widened to avoid overflow)
([int]$int32 + 1)              # Will overflow if you force [int] explicitly
($int64  + 1).GetType().Name   # Int64
($decimal + 0.2).GetType().Name # Decimal
```

For mission‑critical numeric work, it is best to be explicit about types rather than relying entirely on promotion rules, especially where overflow or rounding would be costly.

#### 4.1.1.2 The Modulo Operator (%)

The modulo operator (`%`) returns the remainder after division rather than the quotient. It is frequently used for parity checks (odd/even), clock arithmetic (wrapping after a fixed size), and round‑robin style algorithms.

<!-- Illustrative -->
```powershell
10 % 3   # 1  (10 = 3*3 + 1)
5  % 2   # 1
4  % 2   # 0
```

Modulo is defined for negative numbers too, but the sign of the result matches the dividend (left operand), so `-5 % 2` yields `-1`. In everyday scripting you mostly use it with non‑negative counters and sizes.

**Calculating remainders:** Because `%` is so concise, it often replaces manual “subtract in a loop” logic. For example, determining whether a number is even is as simple as checking whether the remainder when dividing by 2 is zero:

<!-- Illustrative -->
```powershell
$numbers = 0..5
$numbers | ForEach-Object {
    if ($_ % 2 -eq 0) {
        "$_ is even"
    }
    else {
        "$_ is odd"
    }
}
```

This same pattern applies to more complex divisors—for example, day‑of‑week indexes, pagination, or grouping items into fixed‑size batches.

**Cyclical logic implementation (Round Robin):** Modulo shines when you want to cycle through a fixed set of options. Imagine distributing incoming tasks across three servers in a round‑robin pattern:

<!-- Illustrative -->
```powershell
$servers = 'web01','web02','web03'

for ($i = 0; $i -lt 10; $i++) {
    $server = $servers[$i % $servers.Count]
    "Task $i -> $server"
}
```

Because `$i % $servers.Count` always evaluates to `0`, `1`, or `2`, the index wraps automatically whenever it reaches the end of the array. This pattern generalizes to any situation where you need a repeating sequence of indices.

### 4.1.2 The Math Class ([Math]::Round, [Math]::Pow)

Basic arithmetic operators cover a lot of ground, but for more advanced calculations you can call into the .NET `System.Math` class. Its static methods expose a wide range of operations: powers, roots, trigonometry, absolute values, and more. Because PowerShell can call .NET APIs directly, using `[Math]` feels like an extension of the language rather than a separate subsystem.

<!-- Illustrative -->
```powershell
[Math]::Sqrt(25)             # 5
[Math]::Pow(2, 10)           # 1024
[Math]::Abs(-42)             # 42
[Math]::Round(3.14159, 2)    # 3.14
```

The methods on `[Math]` are deterministic and fast—ideal for scripts that need to perform a lot of numeric work without taking a dependency on Excel or other tools.

#### 4.1.2.1 Static Method Performance

Each `[Math]` method is a simple static call into the .NET runtime. There is no PowerShell pipeline overhead or reflection happening at runtime; the call is bound once and then dispatched directly to highly optimized framework code.

In practice this means:

- Using `[Math]` is dramatically faster than trying to emulate the same behavior with PowerShell loops or custom functions.
- When performance matters, prefer a single `[Math]` call over a pipeline of micro‑operations.
- The overhead of the static call itself is negligible compared to the work done by most cmdlets.

<!-- Illustrative -->
```powershell
# Approximate pi using arctangent
[Math]::Atan(1) * 4
```

For large loops or simulations, the bottleneck is almost always your algorithm or I/O, not the cost of the `[Math]` calls themselves.

**Direct IL calls:** Under the hood, PowerShell compiles a call like `[Math]::Sqrt(9)` into a .NET call instruction that directly invokes the `System.Math.Sqrt` method. That method may in turn delegate to hardware‑accelerated CPU instructions (for example, SSE/AVX) when available.

The important takeaway is that there is no string parsing or shell‑style evaluation at this point—the operation is as “close to the metal” as managed code gets. If you are used to spreadsheet formulas or interpreted scripting languages, this level of performance from inside a shell can be pleasantly surprising.

**Comparison to Excel formulas:** If you come from an Excel background, many familiar functions have direct counterparts on `[Math]`. The table below shows a few useful mappings:

| Excel function | PowerShell / .NET equivalent           | Example                                      |
|----------------|----------------------------------------|----------------------------------------------|
| `POWER(x, y)`  | `[Math]::Pow(x, y)`                    | `[Math]::Pow(2, 10)`                         |
| `ROUND(x, n)`  | `[Math]::Round(x, n)`                  | `[Math]::Round(3.14159, 2)`                  |
| `CEILING(x)`   | `[Math]::Ceiling(x)`                   | `[Math]::Ceiling(2.1)`                       |
| `FLOOR(x)`     | `[Math]::Floor(x)`                     | `[Math]::Floor(2.9)`                         |
| `ABS(x)`       | `[Math]::Abs(x)`                       | `[Math]::Abs(-42)`                           |
| `SQRT(x)`      | `[Math]::Sqrt(x)`                      | `[Math]::Sqrt(49)`                           |

Moving your logic from Excel into PowerShell often consists of replacing cell references with variables and swapping Excel functions for their `[Math]` equivalents.

#### 4.1.2.2 MidpointRounding Modes

Rounding seems simple until you start dealing with values exactly halfway between two representable numbers, such as `1.5` or `2.345` when rounding to two decimal places. PowerShell uses .NET’s `MidpointRounding` enumeration to decide how to handle those edge cases.

The crucial detail: by default, PowerShell uses “banker’s rounding” (`MidpointRounding.ToEven`). Instead of always rounding `.5` up, it rounds to the nearest even number. This avoids introducing a bias when aggregating large sets of rounded values.

<!-- Illustrative -->
```powershell
[Math]::Round(1.5)  # 2
[Math]::Round(2.5)  # 2 (not 3)
```

Many users report this behavior as a “bug” the first time they encounter it. It is by design, and it is particularly useful in financial summaries or statistics.

**ToEven (Banker's Rounding) default:** With `MidpointRounding.ToEven`, values exactly halfway between two integers are rounded to whichever integer is even:

- `1.5` becomes `2`
- `2.5` becomes `2`
- `3.5` becomes `4`

For values that are not exact halves, rounding behaves the way you learned in school: `.49` rounds down, `.51` rounds up. The only surprising cases are where the fraction is exactly `.5`.

<!-- Illustrative -->
```powershell
# Default behavior (ToEven)
[Math]::Round(1.5)    # 2
[Math]::Round(2.5)    # 2
[Math]::Round(3.49)   # 3
[Math]::Round(3.51)   # 4
```

This approach keeps large aggregates (for example, total interest paid across thousands of loans) from drifting upward or downward simply because you always rounded in the same direction.

**AwayFromZero requirement for finance:** Some business rules explicitly require “round half up” behavior: any `.5` value must round away from zero, even if that introduces a small bias. The `[Math]::Round` method lets you request this behavior via the `MidpointRounding` parameter:

<!-- Illustrative -->
```powershell
# Round half away from zero, as many finance teams expect
[Math]::Round(2.5, 0, [MidpointRounding]::AwayFromZero)   # 3
[Math]::Round(-2.5, 0, [MidpointRounding]::AwayFromZero)  # -3
```

In PowerShell scripts that deal with invoices, tax calculations, or regulatory reports, it is worth being explicit about the rounding mode instead of relying on the default.

### 4.1.3 Compound Assignment (+=, *=)

Compound assignment operators are small pieces of syntactic sugar that make “update this variable based on its current value” both concise and readable. Instead of repeating the variable name on both sides of the `=`, you can fold the operation and assignment into a single token.

PowerShell supports compound forms for addition, subtraction, multiplication, division, and modulo, among others:

<!-- Illustrative -->
```powershell
$total  = 0
$total += 10
$total -= 3
$total *= 2
$total /= 7
```

The meaning is identical to the long form, but the compact syntax is easier to scan, especially in loops and counters.

#### 4.1.3.1 Syntactic Sugar

The term “syntactic sugar” describes language features that do not add expressive power—they merely make common patterns easier to write and read. Compound assignment operators fall squarely into this category.

Using `+=` or `*=`:

- Avoids repeating the variable name.
- Makes the intent (“increment”, “accumulate”, “scale”) jump out visually.
- Matches the mental model you already have from other languages.

The PowerShell parser simply rewrites the expression into its longhand equivalent before evaluation.

**$a = $a + 1 expansion:** Under the hood, PowerShell treats:

<!-- Illustrative -->
```powershell
$a += 1
```

as if you had written:

<!-- Illustrative -->
```powershell
$a = $a + 1
```

You can observe this by watching the value of `$a` change:

<!-- Illustrative -->
```powershell
$a = 0
$a += 1
$a += 5
$a
```

Output:

<!-- Illustrative -->
```text
6
```

There is no hidden magic; the compound form is purely a convenience over the explicit longer form.

**Readability improvements:** Compound assignment often improves readability by emphasizing the change rather than the mechanics. For example, a running total in a loop:

<!-- Illustrative -->
```powershell
$total = 0
Get-Process | ForEach-Object {
    $total += $_.WorkingSet64
}
"Total memory: {0:N0} bytes" -f $total
```

Compare that to `$total = $total + $_.WorkingSet64`; both are correct, but the version with `+=` communicates “accumulate” more clearly at a glance. For this reason, most PowerShell style guides encourage the compound form where appropriate.

#### 4.1.3.2 Immutable Type Implications

Not all types behave the same way when you modify them. Some .NET types are immutable: once created, they can never change their internal value. Strings are the most common example. When you apply `+=` to an immutable type, PowerShell must create a new instance behind the scenes and update the variable to point to it.

This has two important consequences:

- Frequent `+=` on immutable types can allocate a lot of garbage, hurting performance.
- The apparent “in‑place” update is actually a replacement, which matters if multiple references point to the same object.

**String concatenation under the hood:** Consider building a message one piece at a time:

<!-- Illustrative -->
```powershell
$message = ""
1..5 | ForEach-Object {
    $message += "Item $_`n"
}
```

Each `+=` creates a brand‑new `System.String` instance that contains the previous value plus the new text. For a handful of concatenations this is fine, but in tight loops or large data sets it becomes expensive.

A more efficient pattern is to accumulate into a list and join once, or to use a `StringBuilder`:

<!-- Illustrative -->
```powershell
$builder = [System.Text.StringBuilder]::new()
1..5 | ForEach-Object {
    [void]$builder.AppendLine("Item $_")
}
$message = $builder.ToString()
```

Knowing that `+=` on strings is not free will help you choose the right pattern for your workload.

**Array resizing penalties:** Arrays in .NET are fixed‑size. When you write:

<!-- Illustrative -->
```powershell
$items = @()
1..100 | ForEach-Object {
    $items += $_
}
```

each `+=` forces PowerShell to allocate a new array, copy the existing elements, and append the new value. This results in O(N²) behavior: the total number of copies grows quadratically with the number of elements.

For growing collections, prefer `System.Collections.Generic.List[T]` or `System.Collections.ArrayList]`:

<!-- Illustrative -->
```powershell
$list = [System.Collections.Generic.List[int]]::new()
1..100 | ForEach-Object {
    $list.Add($_)
}
$items = $list.ToArray()
```

Chapter 2 discusses this pattern in more depth, but it is worth reiterating here: compound assignment on arrays is convenient but can be surprisingly expensive.

### 4.1.4 Precedence and Grouping

When an expression contains many operators, PowerShell needs rules to decide which ones to evaluate first. These rules—operator precedence—determine the meaning of expressions like `1 + 2 * 3 - 4` without requiring you to add parentheses everywhere.

PowerShell’s precedence is broadly similar to other C‑style languages: multiplication and division bind more tightly than addition and subtraction; comparison happens after arithmetic; boolean logic and assignment come later. Parentheses always win and are your best tool for making intent explicit.

<!-- Illustrative -->
```powershell
1 + 2 * 3    # 7   (2 * 3 evaluated first)
(1 + 2) * 3  # 9   (parentheses override precedence)
```

#### 4.1.4.1 Operator Precedence Table

The following table summarizes the relative precedence of the operators discussed in this chapter, from highest to lowest. Operators on the same row have equal precedence and are evaluated left‑to‑right.

| Level | Category                     | Examples                          |
|-------|------------------------------|-----------------------------------|
| 1     | Parentheses / Subexpression  | `()`, `$()`, `@()`                |
| 2     | Unary operators              | `-`, `+` (sign), `-not`           |
| 3     | Multiplicative               | `*`, `/`, `%`                     |
| 4     | Additive                     | `+`, `-`                          |
| 5     | Comparison / type tests      | `-eq`, `-gt`, `-like`, `-is`      |
| 6     | Logical                      | `-and`, `-or`, `-xor`             |
| 7     | Assignment / compound assign | `=`, `+=`, `-=`, `*=`, `/=`, `%=` |

This is not a complete list of every PowerShell operator, but it captures the ones you will use most often when writing everyday expressions.

**Arithmetic vs Logical vs Assignment:** Because arithmetic operators sit above comparison and assignment, a composite expression such as:

<!-- Illustrative -->
```powershell
$result = 1 + 2 * 3 -gt 5
```

is evaluated like this:

1. `2 * 3` → `6`
2. `1 + 6` → `7`
3. `7 -gt 5` → `$true`
4. `$result = $true`

If you accidentally assume that `-gt` runs before the arithmetic, you might misinterpret what the code does. Reading from left to right is not enough; you must also keep precedence in mind.

**Unary operators priority:** Unary operators such as numeric negation (`-5`) and logical negation (`-not`) bind tightly to their operands and are evaluated before surrounding binary operators. For example:

<!-- Illustrative -->
```powershell
-not $value -or $otherValue
```

is parsed as:

<!-- Illustrative -->
```powershell
((-not $value) -or $otherValue)
```

Likewise, `-5 * 2` is treated as “negative five, times two” rather than “minus (five times two)”. Parentheses are still your friend when an expression feels ambiguous, but the default binding rules are usually what you expect.

#### 4.1.4.2 Parenthetical Grouping (...)

Parentheses give you the final say over evaluation order. Any expression inside `()` is evaluated first, and the result is then used in the surrounding expression. You can nest parentheses as deeply as you like to make complex logic easier to reason about.

<!-- Illustrative -->
```powershell
(2 + 2) * 3      # 12
2 + (2 * 3)      # 8
```

Parentheses also improve readability even when they are not strictly necessary. If you ever find yourself squinting at a line to understand which parts run first, that is a sign you should add grouping.

**Forcing evaluation order:** Consider the following condition:

<!-- Illustrative -->
```powershell
if ($enabled -and $count -gt 10 -or $force) { ... }
```

This is legal but confusing. The precedence rules mean it is evaluated as:

<!-- Illustrative -->
```powershell
if ( ($enabled -and ($count -gt 10)) -or $force ) { ... }
```

If what you really intend is “either we are enabled and the count is high, or we explicitly forced it”, it is clearer to write the grouped form directly:

<!-- Illustrative -->
```powershell
if ( ($enabled -and ($count -gt 10)) -or $force ) { ... }
```

Explicit grouping reduces surprises when you or someone else revisits the script months later.

**Creating expression contexts:** Parentheses do more than just override precedence; they also produce a value that you can immediately use in another context. This is particularly handy when you want to call a method or access a property on the result of another operation:

<!-- Illustrative -->
```powershell
(Get-Date).Year
(Get-Process pwsh | Sort-Object CPU -Descending | Select-Object -First 1).Id
```

Here, the pipeline runs first, producing a process object, and then the trailing `.Id` property access is applied to that object. Without the parentheses, `.Id` would bind to `Select-Object` rather than to the pipeline’s result.

### 4.1.5 Bitwise Operators (-bAnd, -bOr, -bXor, -bNot)

Bitwise operators operate on the individual bits of integer values. They are indispensable in low‑level scenarios such as networking, permissions flags, and protocol work where multiple boolean values are packed into a single integer.

PowerShell exposes four bitwise operators:

- `-band` – bitwise AND (keeps bits set in both operands).
- `-bor` – bitwise OR (keeps bits set in either operand).
- `-bxor` – bitwise exclusive OR (keeps bits set in one operand but not both).
- `-bnot` – bitwise NOT (inverts every bit).

<!-- Tested on: PowerShell 7.4 -->
```powershell
0b1100 -band 0b1010  # 0b1000 (8)
0b1100 -bor  0b1010  # 0b1110 (14)
0b1100 -bxor 0b1010  # 0b0110 (6)
-bnot 0b0001         # Inverts bits; result is -2 when shown as a signed int
```

(If you are on Windows PowerShell 5.1, where binary literals are not supported, you can use decimal or hexadecimal equivalents instead.)

#### 4.1.5.1 Subnet Mask Calculations

IPv4 networking uses bitwise operations to represent subnets and addresses efficiently. An IP address is a 32‑bit value; a subnet mask is another 32‑bit value that marks which bits belong to the network ID and which to the host ID. Applying a bitwise AND between an address and its mask yields the network ID.

**Masking IP addresses:** The following example computes the network ID for `192.168.10.25` with a `/24` mask:

<!-- Illustrative -->
```powershell
$ip   = [System.Net.IPAddress]::Parse('192.168.10.25')
$mask = [System.Net.IPAddress]::Parse('255.255.255.0')

$ipBytes   = $ip.GetAddressBytes()
$maskBytes = $mask.GetAddressBytes()

$networkBytes = for ($i = 0; $i -lt $ipBytes.Length; $i++) {
    $ipBytes[$i] -band $maskBytes[$i]
}

$networkId = [System.Net.IPAddress]::new([byte[]]$networkBytes)
$networkId.IPAddressToString    # 192.168.10.0
```

Each byte of the IP address is AND‑ed with the corresponding byte of the mask, zeroing out the host bits and leaving only the network portion.

**CIDR block math:** Classless Inter‑Domain Routing (CIDR) notation expresses the size of a subnet as a prefix length, such as `/24`. You can use bitwise shifts to reason about how many host addresses are available:

<!-- Illustrative -->
```powershell
$prefixLength = 24
$hostBits     = 32 - $prefixLength

# 1 left-shifted by hostBits yields the number of addresses
$totalAddresses = 1 -shl $hostBits        # 256 for /24
$usableHosts    = $totalAddresses - 2     # minus network and broadcast

"CIDR /$prefixLength -> $totalAddresses addresses, $usableHosts usable hosts"
```

While higher‑level networking tools hide this math, understanding the bitwise underpinnings makes troubleshooting routing and subnetting problems much easier.

#### 4.1.5.2 Active Directory UserAccountControl

In Active Directory, the `userAccountControl` attribute is a bit field: each bit represents a flag such as “account is disabled” or “password never expires”. Bitwise operators let you manipulate these flags without disturbing the others.

**Flipping bit flags:** Suppose you want to disable a user account by setting the `ACCOUNTDISABLE` flag (value `0x0002`):

<!-- Illustrative -->
```powershell
$ACCOUNTDISABLE = 0x0002

$user = Get-ADUser -Identity 'jdoe' -Properties userAccountControl
$user.UserAccountControl = $user.UserAccountControl -bor $ACCOUNTDISABLE

Set-ADUser -Instance $user
```

Using `-bor` ensures only the chosen bit is turned on; all other bits remain as they were.

**Checking specific bit states:** To check whether a particular flag is currently set, AND the field with the flag and compare the result to zero:

<!-- Illustrative -->
```powershell
$PASSWD_NEVER_EXPIRES = 0x10000

$user = Get-ADUser -Identity 'jdoe' -Properties userAccountControl
$flagSet = ($user.UserAccountControl -band $PASSWD_NEVER_EXPIRES) -ne 0

if ($flagSet) {
    "Password for $($user.SamAccountName) is configured to never expire."
}
else {
    "Password for $($user.SamAccountName) will expire according to policy."
}
```

This pattern—`if (($flags -band $mask) -ne 0)`—shows up throughout Windows APIs and configuration systems, not just Active Directory.

## 4.2 Comparison Operators

Comparison operators let you ask questions about your data: are these values equal, which one is larger, does this item appear in that list, does this string match the pattern? In PowerShell they are all written with the `-verb` style syntax—`-eq`, `-gt`, `-like`, and so on—instead of symbols like `==` or `<`.

Because PowerShell operates on objects, comparison semantics depend on the underlying types. Comparing integers behaves differently from comparing strings, which behaves differently from comparing dates. The comparison operators hide this complexity behind a clean, readable surface.

### 4.2.1 Equality (-eq, -ne) and Case Sensitivity (-ceq)

The most fundamental comparisons check whether two values are equal (`-eq`) or not equal (`-ne`). In PowerShell, these operators are:

- Case‑insensitive by default for strings.
- Culture‑aware (they respect your current locale’s rules).
- Overloaded for a wide variety of types.

<!-- Illustrative -->
```powershell
"a" -eq "A"            # True (case-insensitive)
"a" -ceq "A"           # False (case-sensitive)
42  -eq 42.0           # True (numeric comparison)
(Get-Date) -eq (Get-Date)  # False: different timestamps
```

Understanding the default case‑insensitive behavior avoids subtle bugs when porting logic from languages like C# or Python that default to case‑sensitive comparisons.

#### 4.2.1.1 Default Case Insensitivity

When both operands are strings and you use `-eq` or `-ne`, PowerShell performs a case‑insensitive comparison using your current culture (for example, `en-US`). That means `"SERVER01"` and `"server01"` are treated as equal, which is often exactly what you want when dealing with hostnames, user names, or file paths on Windows.

This behavior carries over to collection comparisons as well:

<!-- Illustrative -->
```powershell
$names = 'Alice','Bob','Charlie'

'Alice'  -in $names    # True
'alice'  -in $names    # True (case-insensitive)
```

If your logic depends on precise casing—for example, when validating passwords or working with case‑sensitive file systems—you must opt into the `c` variants of the operators.

**String comparison culture usage:** PowerShell’s string comparisons are culture‑sensitive. Under the hood, the engine uses `System.Globalization.CompareInfo` for the current UI culture, which can influence how characters are considered equal or how they sort.

For example, in some cultures accented characters may be treated as variants of the same base character, while in others they are distinct. This usually matches user expectations when working with natural language data, but it is different from byte‑wise comparisons:

<!-- Illustrative -->
```powershell
$PSCulture                # e.g., en-US, de-DE

"straße" -eq "STRASSE"    # May be True in some cultures
"straße" -ceq "STRASSE"   # False (case-sensitive)
```

When you need invariant, culture‑agnostic comparisons (for example, protocol identifiers or hash values), you can explicitly use .NET APIs such as `[String]::Equals()` with `StringComparison.OrdinalIgnoreCase`.

**"A" -eq "a" -> True:** A simple way to demonstrate the default behavior is to compare two single‑character strings that differ only in case:

<!-- Illustrative -->
```powershell
"A" -eq "a"    # True
"A" -ceq "a"   # False
```

Remember that `-eq` and `-ne` ignore case for strings unless you prefix them with `c`. This surprises many users the first time they assume PowerShell behaves like C#.

#### 4.2.1.2 The 'c' Prefix

Every string comparison operator has a case‑sensitive variant: just add a `c` prefix. The semantics are otherwise identical; only the casing rules change.

Common pairs include:

- `-eq` / `-ceq`
- `-ne` / `-cne`
- `-like` / `-clike`
- `-match` / `-cmatch` (regular expressions, covered in chapter 8)

Use these when you need to treat `"User"` and `"user"` as distinct values.

**Forcing case checks (-ceq, -cne):** Here is a concrete example that contrasts the default and case‑sensitive versions:

<!-- Illustrative -->
```powershell
$expected = 'ProdServer'

'prodserver' -eq  $expected   # True
'prodserver' -ceq $expected   # False

if ('Admin' -cne 'admin') {
    'These two strings differ by case.'
}
```

When in doubt, prefer the `c` variants in security‑sensitive contexts, where silently treating two differently cased values as equivalent could be problematic.

**Password validation scenarios:** Password policies are typically case‑sensitive, and it is common to validate whether a proposed password meets certain rules such as “must contain an uppercase and a lowercase letter”. Case‑sensitive comparisons make these checks straightforward:

<!-- Illustrative -->
```powershell
$password = 'P@ssw0rd'

$hasUpper = ($password -cmatch '[A-Z]')
$hasLower = ($password -cmatch '[a-z]')
$hasDigit = ($password -match '\d')

if ($hasUpper -and $hasLower -and $hasDigit) {
    'Password meets basic complexity requirements.'
}
else {
    'Password is missing one or more required character classes.'
}
```

Here `-cmatch` ensures that the uppercase and lowercase checks respect case exactly as written.

### 4.2.2 Magnitude (-gt, -lt, -ge, -le)

Magnitude operators compare “how big” values are relative to one another:

- `-gt` – greater than.
- `-lt` – less than.
- `-ge` – greater than or equal.
- `-le` – less than or equal.

PowerShell overloads these operators for numerics, dates, strings, and even custom types that implement comparison interfaces. The engine chooses the comparison strategy based on the operand types.

#### 4.2.2.1 Numeric Comparison

For numbers, the magnitude operators behave in the way you would expect from a strongly typed language: the engine converts values to compatible numeric types and compares them arithmetically.

<!-- Illustrative -->
```powershell
10   -gt  5       # True
3.14 -lt  4       # True
5    -ge  5       # True
5    -le  4       # False
```

If you mix numeric types, PowerShell promotes to a common type before comparing.

**Integer vs Double comparison:** When comparing an integer to a floating‑point number, PowerShell widens the integer to a `double` and performs a standard floating‑point comparison:

<!-- Illustrative -->
```powershell
10 -gt 9.9       # True
10 -eq 10.0      # True
10 -eq 10.00001  # False
```

The usual caveats about floating‑point precision apply: values that look equal in decimal may differ slightly in binary representation. For high‑precision comparisons, consider using `[decimal]` instead.

**Signed vs Unsigned handling:** PowerShell’s numeric literals are signed by default, and the magnitude operators handle negative values naturally:

<!-- Illustrative -->
```powershell
-5 -lt 0      # True
-5 -gt -10    # True
-5 -ge -5     # True
```

If you explicitly use unsigned types (for example, `[uint32]`), be careful when comparing them to signed values—mixing the two can yield surprising results due to different ranges. In most scripting code it is simpler to stick with signed integers (`int`/`long`) unless you have a specific need for unsigned types.

#### 4.2.2.2 String Comparison (Lexicographical)

When you compare strings with magnitude operators, PowerShell performs a lexicographical comparison: it compares the first character of each string, then the second, and so on, according to the rules of the current culture.

<!-- Illustrative -->
```powershell
"Apple"  -lt "Banana"  # True
"Server2" -lt "Server10"  # False (because "2" > "1")
"2"       -lt "10"         # False for strings; cast to [int] for numeric intent
```

This behavior is similar to dictionary order, but digits and special characters can make results less intuitive.

**Alphabetical sorting logic:** Lexicographical comparison can be visualized as the order you would see in a sorted list:

<!-- Illustrative -->
```powershell
'Apple','Banana','Cherry' | Sort-Object
# Apple, Banana, Cherry

"Apple"  -lt "Banana"    # True
"Cherry" -gt "Banana"    # True
```

The operators and `Sort-Object` both rely on the same underlying comparison logic, so comparisons and sorting stay consistent.

**ASCII value considerations:** Special characters, digits embedded in strings, and case differences can produce surprising comparisons:

<!-- Illustrative -->
```powershell
"Server10" -lt "Server2"     # True (string comparison, not numeric)
"Zebra"    -lt "apple"       # Depends on culture and case rules
"#comment" -lt "Alpha"       # "#" may sort before letters
```

If you need “natural sort” behavior (for example, `Server2` should come before `Server10`), you may need to extract numeric portions and compare them separately, or use specialized sorting utilities.

### 4.2.3 Collection containment (-in, -contains)

Containment operators check whether an element appears in a collection. PowerShell provides two forms that differ primarily in the direction of the operands:

- `-in` – “item in collection?”
- `-contains` – “collection contains item?”

They are functionally equivalent but read differently.

#### 4.2.3.1 Operator Direction

With `-in`, the scalar value comes first and the collection comes second. With `-contains`, the collection is on the left and the scalar is on the right. Both operators test membership and return `$true` or `$false`.

**Item -in Collection (Readability preferred):** The `-in` operator (introduced in PowerShell 3.0) usually reads more like natural language:

<!-- Illustrative -->
```powershell
$user = 'Alice'
$admins = 'Alice','Bob','Charlie'

if ($user -in $admins) {
    "$user is an administrator."
}
```

Because it mirrors English (“is the user in admins?”), many teams prefer `-in` for new code.

**Collection -contains Item (Legacy):** The older `-contains` operator reverses the order:

<!-- Illustrative -->
```powershell
$admins = 'Alice','Bob','Charlie'

if ($admins -contains 'Alice') {
    'Alice is an administrator.'
}
```

You will see `-contains` in older scripts and blog posts, so it is important to be comfortable reading it, even if you choose to write new code with `-in`.

#### 4.2.3.2 Performance

**Linear search O(N):** In big‑O terms, containment checks are O(N) with respect to the size of the collection. You can verify this using simple timing experiments:

<!-- Illustrative -->
```powershell
$small = 1..1000
$big   = 1..1000000

Measure-Command { 999  -in $small   } | Select-Object -ExpandProperty TotalMilliseconds
Measure-Command { 9999 -in $big     } | Select-Object -ExpandProperty TotalMilliseconds
```

As the list grows, the time required for each lookup grows proportionally, because every element must be examined until a match is found or the end is reached.

**When to switch to HashSets:** For very large collections or performance‑critical scenarios, it is more efficient to use a hash‑based data structure such as `System.Collections.Generic.HashSet[T]`, which offers near‑constant‑time lookups:

<!-- Illustrative -->
```powershell
$users = 1..1000000
$set   = [System.Collections.Generic.HashSet[int]]::new()
$set.UnionWith($users)

$target = 999999
if ($set.Contains($target)) {
    "$target is present."
}
```

Building the set has an upfront cost, but once created, membership tests are extremely fast regardless of collection size.

### 4.2.4 Pattern Matching (-like, -notlike)

Pattern‑matching operators let you perform wildcard searches against strings without dropping into full regular expressions. The `-like` operator checks whether a string matches a wildcard pattern; `-notlike` is its negation.

<!-- Illustrative -->
```powershell
"Server01" -like "Server*"   # True
"Server01" -notlike "DB*"    # True
```

Wildcards are particularly useful for filtering lists of file names, computer names, and other structured identifiers.

#### 4.2.4.1 Wildcard Syntax

Wildcard patterns in PowerShell follow a simple mini‑language that is also used in cmdlets like `Get-ChildItem -Filter`:

- `*` – matches zero or more characters.
- `?` – matches exactly one character.
- `[a-z]` – matches any single character in a range or set.

These wildcards operate on text, not on arbitrary objects, so arguments are usually strings or properties converted to strings.

**Asterisk (*) and Question mark (?):** The two most commonly used wildcards are `*` and `?`:

<!-- Illustrative -->
```powershell
"Server01" -like "Server*"     # True: "Server" followed by anything
"Server01" -like "Server??"    # True: "Server" followed by two chars
"Server01" -like "Server0?"    # True
"Server01" -like "Server1?"    # False
```

Use `*` when you do not know (or care) how many characters will follow; use `?` when the number of characters is fixed but their specific values may vary.

**Character sets [a-z] in wildcards:** Bracket expressions let you constrain a single character to a set or range:

<!-- Illustrative -->
```powershell
"Server7"  -like "Server[0-9]"   # True: any digit
"ServerX"  -like "Server[A-Z]"   # True: any uppercase letter
"ServerA"  -like "Server[!0-9]"  # True: not a digit (using !) 
```

This is convenient for matching identifiers with embedded numeric or alphabetic slots, such as host numbers or environment codes.

#### 4.2.4.2 WQL Compatibility

PowerShell wildcards are conceptually similar to those used in SQL and WMI Query Language (WQL), but the symbols differ. Understanding the mapping makes it easier to translate between PowerShell filters and external query languages.

**Translating -like to SQL LIKE:** In SQL, the `LIKE` operator uses `%` for “any number of characters” and `_` for “exactly one character”. When you port a condition from PowerShell to SQL (or vice versa), remember to translate the wildcard characters as well as the syntax:

| Concept                  | PowerShell `-like` | SQL / WQL `LIKE` |
|--------------------------|--------------------|------------------|
| Any characters           | `*`                | `%`              |
| Single character         | `?`                | `_`              |
| Character range/set      | `[a-z]`            | `[a-z]`          |

For example, `Name -like 'Server*'` becomes `WHERE Name LIKE 'Server%'` in SQL.

**Escaping wildcards:** Sometimes you need to search for a literal `*` or `?` in a string—for example, when dealing with file names that contain these characters. To do this with `-like`, escape the wildcard by prefixing it with the backtick (PowerShell’s escape character):

<!-- Illustrative -->
```powershell
"*literal*"  -like '`*literal`*'   # True
"file?.txt" -like 'file`?.txt'     # True
```

Alternatively, you can fall back to `-eq` for exact string matches and avoid wildcards altogether.

### 4.2.5 Type Comparison (-is, -isnot)

Type comparison operators let you ask questions about the runtime type of an object. The `-is` operator checks whether an object is of a given type (or a subtype of it); `-isnot` is the negation.

<!-- Illustrative -->
```powershell
42       -is [int]       # True
42       -is [object]    # True
"hello"  -is [int]       # False
```

These operators are invaluable when writing functions that accept flexible input but need to branch behavior based on what was actually passed.

#### 4.2.5.1 Inheritance Checking

Because .NET types form an inheritance hierarchy, `-is` works with base classes as well as exact types. An object `-is` its own type, any base class, and any interface it implements.

**Checking base classes:** Many value types, including integers, derive from `System.ValueType`. You can test this relationship directly:

<!-- Illustrative -->
```powershell
$number = 5

$number -is [int]       # True
$number -is [ValueType] # True
$number -is [object]    # True
$number -is [string]    # False
```

This is particularly useful when you accept `[object]` parameters but want to treat value types differently from reference types.

**Interface implementation checks:** You can also use `-is` to see whether an object implements a particular interface. For example, both integers and strings implement `IComparable`, which enables sorting and comparison:

<!-- Illustrative -->
```powershell
$number  = 5
$text    = 'hello'
$object  = New-Object PSObject

$number -is [IComparable]   # True
$text   -is [IComparable]   # True
$object -is [IComparable]   # False
```

This pattern helps you write generic utilities that adapt to the capabilities of the objects they receive.

#### 4.2.5.2 Polymorphic Logic

Once you can test types at runtime, you can write polymorphic code—logic that behaves differently depending on what kind of object it is given. PowerShell’s dynamic nature makes this straightforward with `if` or `switch`.

**Branching based on object type:** Consider a function that formats input differently depending on whether it is a date, a number, or something else:

<!-- Illustrative -->
```powershell
param($InputObject)

if ($InputObject -is [DateTime]) {
    $InputObject.ToString('yyyy-MM-dd')
}
elseif ($InputObject -is [double]) {
    '{0:N2}' -f $InputObject
}
else {
    $InputObject.ToString()
}
```

This kind of branching is safer and clearer than trying to infer type from string patterns.

**Safe casting preparation:** Before casting with `[Type]` or using `-as`, it is wise to check whether the cast is likely to succeed:

<!-- Illustrative -->
```powershell
if ($value -is [int]) {
    $intValue = [int]$value   # Safe: already known to be an int
}
else {
    Write-Warning "Expected an integer but received $($value.GetType().Name)"
}
```

In situations where you prefer a non‑throwing conversion, the `-as` operator returns `$null` on failure; combining it with `-is` or a null check yields robust casting code.

## 4.3 Logical and Redirection Operators

Logical operators combine boolean conditions; redirection operators control where output and errors go. Together they give you control over both the decision‑making and the “plumbing” aspects of your scripts.

In PowerShell, logical operators (`-and`, `-or`, `-xor`, `-not`) work with any values that can be converted to `$true` or `$false`. Redirection operators (`>`, `>>`, `2>`, `2>&1`, and friends) operate on the engine’s multiple output streams, letting you capture or suppress information precisely.

### 4.3.1 Boolean Logic (-and, -or, -xor, -not)

Boolean logic operators combine conditions to answer questions like “are all of these true?”, “is at least one true?”, or “exactly one?”. They are evaluated left‑to‑right with the precedence rules discussed earlier.

<!-- Illustrative -->
```powershell
($x -gt 10) -and ($y -lt 5)
($status -eq 'Success') -or $force
($a -xor $b)   # True if exactly one of $a or $b is true
-not $alreadyProcessed
```

These operators form the backbone of `if`, `while`, and `do` conditions throughout your scripts.

#### 4.3.1.1 Short-Circuit Evaluation

PowerShell’s logical operators are short‑circuiting: they stop evaluating operands as soon as the final answer is known. This avoids unnecessary work and prevents side effects from running when they are not needed.

**Stopping at first False in AND:** For an `-and` expression to be true, both sides must be true. If the left side evaluates to `$false`, the right side is never evaluated:

<!-- Illustrative -->
```powershell
function Test-Expensive {
    Write-Host "Expensive call ran"
    return $true
}

$flag = $false

# The right-hand side is never called
if ($flag -and (Test-Expensive)) {
    "Won't run"
}
```

This allows idioms like “check cheap guard condition first, then expensive operation” without worrying about unnecessary calls.

**Stopping at first True in OR:** For an `-or` expression to be true, only one side needs to be true. If the left side evaluates to `$true`, the right side is never evaluated:

<!-- Illustrative -->
```powershell
$cached = Get-Item -Path 'HKCU:\Software\MyApp' -ErrorAction SilentlyContinue

if ($cached -or (Test-Path -Path 'HKCU:\Software\MyApp')) {
    'Configuration key exists.'
}
```

Here `Test-Path` runs only if `$cached` is `$null` or otherwise treated as `$false`.

#### 4.3.1.2 Precedence in Complex Logic

Complex conditions that mix `-and` and `-or` can be hard to read, and precedence rules may lead to interpretations you did not intend. Parentheses and whitespace are cheap ways to make logic explicit.

**Parentheses necessity:** Without parentheses, an expression like:

<!-- Illustrative -->
```powershell
$approved -and $inBudget -or $urgent
```

is evaluated as:

<!-- Illustrative -->
```powershell
($approved -and $inBudget) -or $urgent
```

If you intended “approved and (in budget or urgent)”, you must write it that way:

<!-- Illustrative -->
```powershell
$approved -and ($inBudget -or $urgent)
```

Whenever a condition reads ambiguously in plain English, add parentheses until the grouping is obvious.

**Readable boolean expressions:** For more complicated conditions, spread the logic across multiple lines and use indentation for clarity:

<!-- Illustrative -->
```powershell
if (
    ($status -eq 'Success' -or $force) -and
    ($retries -lt 3) -and
    -not $IsPreview
) {
    'Proceed with operation.'
}
```

Lining up operators and grouping related clauses makes it much easier to reason about the condition and change it later without breaking behavior.

### 4.3.2 Output Redirection (>, >>, 2>, 2>&1)

PowerShell sends different kinds of output to separate streams: success output, error output, warnings, verbose messages, and so on. Redirection operators let you send those streams to files, merge them, or discard them.

The most common redirections mirror those in traditional shells:

- `>` – overwrite a file with success output.
- `>>` – append success output to a file.
- `2>` – send the error stream to a file.
- `2>&1` – merge the error stream into the success stream.

#### 4.3.2.1 File System Redirection

Redirecting success output to a file is a quick way to capture results without writing dedicated export code.

**Overwrite (>) vs Append (>>):** Use `>` when you want to replace a file entirely, and `>>` when you want to add to the end:

<!-- Illustrative -->
```powershell
Get-Service | Select-Object -First 10 >  services.txt   # Overwrite
Get-Service | Select-Object -First 5  >> services.txt   # Append
```

Be careful with `>`: it truncates the file before writing. If you need to preserve existing content, always use `>>` or explicitly back up the file first.

**Encoding defaults (UTF-16 LE vs UTF8):** On Windows PowerShell 5.1, redirection uses UTF‑16 LE encoding by default. PowerShell 7 and later switched to UTF‑8 without a byte‑order mark (BOM) to better interoperate with cross‑platform tools.

The difference matters when other programs consume the file:

| PowerShell edition     | Default redirection encoding |
|------------------------|------------------------------|
| Windows PowerShell 5.1 | UTF‑16 LE                    |
| PowerShell 7+          | UTF‑8 (no BOM)               |

If you need explicit control over encoding, use `Out-File` with the `-Encoding` parameter instead of bare `>` or `>>`:

<!-- Illustrative -->
```powershell
Get-Content data.json | Out-File -FilePath out.txt -Encoding UTF8
```

Ordering matters when you merge and redirect streams. For example, `2>&1 > file.txt` merges errors into the success stream *before* success is redirected, so both end up in `file.txt`. Reversing the order (`> file.txt 2>&1`) would redirect success to the file but leave errors flowing to the console.

#### 4.3.2.2 Stream Merging

Sometimes you want to treat errors as normal output—for example, when capturing everything a tool prints, regardless of whether it wrote to stdout or stderr. PowerShell uses numeric stream IDs and the `>&` syntax to redirect one stream into another.

**2>&1 (Error to Success stream):** `2>&1` means “send stream 2 (error) to the same destination as stream 1 (success)”. This is often used to capture both success and error messages into a single file or variable:

<!-- Illustrative -->
```powershell
# Capture both success and error output
$output = & git status 2>&1

$output | ForEach-Object { ">> $_" }
```

Once merged, errors are no longer treated specially by PowerShell—they become regular objects in the success stream.

**Capturing stderr from native apps:** Many native tools write warnings or even normal progress messages to stderr. If you only capture stdout, you may miss important information. Redirecting stderr into stdout ensures you do not lose anything:

<!-- Illustrative -->
```powershell
# Save all output from a native command
& kubectl get pods 2>&1 | Set-Content -Path pods.log
```

You can also redirect individual streams to `$null` or separate log files, as covered later in this section.

### 4.3.3 Stream Manipulation (Success, Error, Warning, etc.)

PowerShell’s multi‑stream output model is a major departure from traditional shells. Instead of a single byte stream with embedded error messages, PowerShell has dedicated channels for different kinds of information. Understanding these streams lets you control what the user sees and what your scripts treat as data.

#### 4.3.3.1 The 6 Streams of PowerShell

There are six primary output streams:

| ID | Name        | Typical use                                   |
|----|-------------|-----------------------------------------------|
| 1  | Success     | Data and objects returned by commands         |
| 2  | Error       | Non‑terminating and terminating error records |
| 3  | Warning     | Yellow warning messages                       |
| 4  | Verbose     | Detailed progress and diagnostic output       |
| 5  | Debug       | Low‑level debugging messages                  |
| 6  | Information | Structured informational messages             |

Most of the time you interact with stream 1 and 2; the others are opt‑in and controlled via preference variables.

**Success, Error, Warning, Verbose, Debug, Information:** Each stream has dedicated cmdlets or parameters:

- Success: normal output from any cmdlet or function.
- Error: `Write-Error`.
- Warning: `Write-Warning`.
- Verbose: `Write-Verbose` (enabled with `-Verbose` or `$VerbosePreference`).
- Debug: `Write-Debug`.
- Information: `Write-Information`.

<!-- Illustrative -->
```powershell
Write-Output    "This is success output."
Write-Warning   "This is a warning."
Write-Verbose   "This is verbose output."   -Verbose
Write-Error     "This is an error."
```

Keeping these concerns separate makes it easier to build robust automation that captures or suppresses particular kinds of output as needed.

**Preferences ($VerbosePreference):** Preference variables control how certain streams behave by default. For example:

- `$VerbosePreference`
- `$DebugPreference`
- `$ErrorActionPreference`
- `$InformationPreference`

Each variable supports values such as `SilentlyContinue`, `Continue`, `Stop`, and `Inquire`. For example:

<!-- Illustrative -->
```powershell
$VerbosePreference = 'Continue'
Write-Verbose "Now you will see this."    # Displayed

$VerbosePreference = 'SilentlyContinue'
Write-Verbose "Now you won't."            # Hidden
```

Adjusting these preferences at the top of a script is a powerful way to tune its noise level without changing individual calls.

#### 4.3.3.2 Redirection to $null

Sometimes you simply do not care about a particular stream and want to discard it. PowerShell treats `$null` as a valid redirection target, similar to `/dev/null` on Unix‑like systems.

**> $null vs Out-Null:** There are two common ways to suppress success output:

<!-- Illustrative -->
```powershell
Get-Process > $null       # Parser-level redirection
Get-Process | Out-Null    # Cmdlet in the pipeline
```

Both prevent data from reaching the console, but they have different performance characteristics. `> $null` is handled by the parser and short‑circuits the pipeline; `Out-Null` still constructs pipeline objects and passes them to a cmdlet that discards them.

**Performance difference:** In tight loops, the choice between `> $null` and `Out-Null` can matter:

<!-- Illustrative -->
```powershell
Measure-Command {
    1..10000 | ForEach-Object { Get-Date > $null }
} | Select-Object -ExpandProperty TotalMilliseconds

Measure-Command {
    1..10000 | ForEach-Object { Get-Date | Out-Null }
} | Select-Object -ExpandProperty TotalMilliseconds
```

Redirecting to `$null` is consistently faster because PowerShell avoids invoking an extra cmdlet for each object. Reserve `Out-Null` for cases where you specifically need pipeline semantics (for example, when composing reusable pipeline segments).

### 4.3.4 The Subexpression Operator $()

The subexpression operator `$()` evaluates a mini‑script and yields its result inline. It is most commonly used inside double‑quoted strings and when you need to treat a multi‑statement block as a single expression.

<!-- Illustrative -->
```powershell
"Today is $((Get-Date).DayOfWeek)."
```

Anything inside `$()` is executed first, and the resulting value is substituted into the surrounding context.

#### 4.3.4.1 Evaluating Multiple Statements

Subexpressions are not limited to single statements; you can separate multiple statements with semicolons. The value of the subexpression is the collection of all output produced by those statements.

**Semicolon separation inside $():** For example:

<!-- Illustrative -->
```powershell
$result = $(Get-Date; Get-Random -Minimum 1 -Maximum 10)
$result.GetType().Name    # Object[] (array of results)
```

Here the subexpression returns an array containing both the `DateTime` and the random number. This can be a concise way to build small composite structures.

**Returning arrays from loops:** You can also use `$()` to capture the output of control structures that are otherwise statements, such as `foreach`:

<!-- Illustrative -->
```powershell
$results = $(foreach ($n in 1..5) {
    $n * $n
})

$results          # 1 4 9 16 25
$results.GetType().Name   # Object[]
```

Wrapping the `foreach` in `$()` converts it into an expression whose value you can assign or pass to other commands.

#### 4.3.4.2 Interpolation Context

Inside double‑quoted strings, `$()` lets you embed arbitrary expressions rather than simple variables. This is essential when you want to access properties, call methods, or perform calculations before inserting the result into the string.

**Property access inside strings "Count: $($x.Count)":** Without subexpressions, PowerShell’s string interpolation stops at the first character that cannot be part of a variable name. To access members, you must use `$()`:

<!-- Illustrative -->
```powershell
$processes = Get-Process
"Total processes: $($processes.Count)"
```

If you tried `"Total processes: $processes.Count"`, PowerShell would look for a variable literally named `$processes.Count`, which does not exist.

**Math inside strings:** Subexpressions are also handy for inline calculations:

<!-- Illustrative -->
```powershell
$year = (Get-Date).Year
"In two years it will be $($year + 2)."
"The square of 7 is $((7 * 7))."
```

This keeps formatting logic close to where the string is defined instead of scattering temporary variables throughout your script.

### 4.3.5 The Array Subexpression @()

The array subexpression operator `@()` takes whatever is inside it and ensures the result is an array. This solves one of the trickiest aspects of early PowerShell versions: commands that return a scalar when there is only one result and an array when there are many.

<!-- Illustrative -->
```powershell
$oneItem   = Get-Process -Name pwsh -ErrorAction SilentlyContinue
$alwaysArr = @(Get-Process -Name pwsh -ErrorAction SilentlyContinue)

$oneItem.GetType().Name    # May be 'Process' or 'Object[]'
$alwaysArr.GetType().Name  # Always 'Object[]'
```

By forcing array context, you can write loops and checks that behave consistently regardless of how many items are returned.

#### 4.3.5.1 Forcing Array Context

`@()` wraps its contents in an array if needed; if the contents are already an array, they are passed through unchanged.

**Ensuring .Count property exists (Pre-PS 3.0):** Before PowerShell 3.0, many cmdlets returned a bare scalar when there was only one match, which meant accessing `.Count` could fail:

<!-- Illustrative -->
```powershell
$result = Get-Service -Name 'Spooler'   # Single service

$result.Count    # In older versions, this was $null or invalid
```

Wrapping the call in `@()` guarantees that `.Count` exists and behaves uniformly:

<!-- Illustrative -->
```powershell
$result = @(Get-Service -Name 'Spooler')
$result.Count    # 1, even if only one service was returned
```

Newer versions of PowerShell are more consistent, but `@()` remains a useful defensive tool.

**Wrapping single objects or nulls:** `@()` also normalizes `null` results, which simplifies downstream logic:

<!-- Illustrative -->
```powershell
$services = @(Get-Service -Name 'DefinitelyDoesNotExist' -ErrorAction SilentlyContinue)

$services.Count   # 0 instead of throwing or being $null

foreach ($svc in $services) {
    # Safe even when there were no matches
    $svc.Name
}
```

Instead of special‑casing `$null`, you can treat “no results” as “empty array”, which is often easier to work with.

#### 4.3.5.2 Performance Cost

As with any abstraction, `@()` has a small but real cost: it forces the creation of an array object even when you did not strictly need one. In most scripts this cost is negligible, but in very hot code paths it can add up.

**Creation of object[] array:** Each time you use `@()`, PowerShell allocates a new `object[]` array to hold the contents. For small collections this is cheap, but if you are wrapping the results of large pipelines repeatedly, the overhead can become significant.

<!-- Illustrative -->
```powershell
Measure-Command {
    1..10000 | ForEach-Object {
        $x = @($_)
    }
} | Select-Object -ExpandProperty TotalMilliseconds
```

Use this pattern where it meaningfully simplifies your logic, not as a reflex around every command.

**Unnecessary copying if already array:** If the value you pass to `@()` is already an array, PowerShell creates a shallow copy rather than reusing the original reference. This can be a waste of allocations when you already know the type:

<!-- Illustrative -->
```powershell
$data      = 1..1000
$sameData  = @($data)    # New array, same contents

[object]::ReferenceEquals($data, $sameData)   # False
```

When you are certain you already have an array, skip `@()` to avoid unnecessary copying.

## 4.4 Putting It Together

So far we have examined each operator family in isolation. Real scripts, however, combine arithmetic, comparison, and logical operators inside pipelines and cmdlets. This section shows how the pieces fit together in day‑to‑day PowerShell work.

The goal is not to introduce new operators, but to demonstrate patterns that make your code clearer and more idiomatic once you understand the building blocks from earlier sections.

### 4.4.1 Filtering Objects with Composite Conditions

One of the most common uses of operators is in `Where-Object` filters. Inside the script block you can use any of the operators covered in this chapter to express rich conditions:

<!-- Illustrative -->
```powershell
Get-Process |
    Where-Object {
        $_.CPU -gt 5 -and
        $_.Name -like 'pwsh*' -and
        ($_.StartTime -gt (Get-Date).AddHours(-8))
    } |
    Sort-Object CPU -Descending
```

This expression combines magnitude comparisons (`-gt`), pattern matching (`-like`), arithmetic (`AddHours`), and boolean logic (`-and`) to select exactly the processes you care about.

### 4.4.2 Calculated Properties in Select-Object

`Select-Object` lets you define calculated properties using expressions. These often include arithmetic and conditional operators to derive new values from existing ones.

<!-- Illustrative -->
```powershell
Get-Service |
    Select-Object -First 5 -Property @{
        Name       = 'Name'
        Expression = { $_.Name }
    }, @{
        Name       = 'IsRunning'
        Expression = { $_.Status -eq 'Running' }
    }, @{
        Name       = 'UptimeMinutes'
        Expression = {
            if ($_.Status -eq 'Running' -and $_.StartType -ne 'Disabled' -and $_.CanStop) {
                [int]((Get-Date) - $_.StartTime).TotalMinutes
            }
            else {
                $null
            }
        }
    }
```

Because expressions are just PowerShell code, any operator you have learned so far is available inside these calculated fields.

### 4.4.3 Reusable Predicate ScriptBlocks

You can store expression blocks in variables and reuse them across cmdlets. This is a powerful way to encapsulate complex logic without repeating it everywhere.

<!-- Illustrative -->
```powershell
$IsCriticalProcess = {
    ($_.Name -like 'sql*' -or $_.Name -like 'iis*') -and
    $_.CPU -gt 1
}

Get-Process | Where-Object $IsCriticalProcess
```

Here the predicate combines pattern matching and numeric comparison. You can reuse `$IsCriticalProcess` anywhere a script block is expected, such as in `Where-Object` or `ForEach-Object`.

### 4.4.4 Capstone: Process Health Triage

This capstone example combines arithmetic, comparison, and boolean operators in a single workflow. It filters a live process list, computes derived values, classifies risk levels, and summarizes the results with a small counter using compound assignment.

<!-- Illustrative -->
```powershell
$cpuMinutesWarning = 5
$memoryMbWarning   = 500
$namePattern       = 'sql*'

$flagged = Get-Process -ErrorAction SilentlyContinue |
    Where-Object {
        $_.CPU -ne $null -and (
            $_.CPU -gt ($cpuMinutesWarning * 60) -or
            ($_.WorkingSet64 / 1MB) -gt $memoryMbWarning -or
            $_.ProcessName -like $namePattern
        )
    } |
    Select-Object ProcessName, Id,
        @{ Name = 'CpuMinutes'; Expression = { [Math]::Round(($_.CPU / 60), 2) } },
        @{ Name = 'MemoryMB';   Expression = { [Math]::Round(($_.WorkingSet64 / 1MB), 1) } },
        @{ Name = 'AlertLevel'; Expression = {
            if (($_.CPU -gt ($cpuMinutesWarning * 120)) -or (($_.WorkingSet64 / 1MB) -gt ($memoryMbWarning * 2))) {
                'High'
            }
            elseif (($_.CPU -gt ($cpuMinutesWarning * 60)) -or (($_.WorkingSet64 / 1MB) -gt $memoryMbWarning)) {
                'Medium'
            }
            else {
                'Review'
            }
        } }

$highCount = 0
foreach ($p in $flagged) {
    if ($p.AlertLevel -eq 'High') {
        $highCount += 1
    }
}

$flagged | Sort-Object AlertLevel, CpuMinutes -Descending
"High-alert process count: $highCount"
```

The key interaction is not any single operator, but the combination: arithmetic converts thresholds into seconds and megabytes, comparisons decide whether each process crosses a limit, and boolean operators compose those checks into one readable predicate.

### 4.4.5 Operator Patterns Cheat Sheet

The table below summarizes a few everyday tasks and the operator combinations that implement them. Use it as a mental checklist when deciding how to translate a requirement into an expression.

| Task                                      | Example expression                                                |
|-------------------------------------------|-------------------------------------------------------------------|
| Clamp value to a range                    | `[Math]::Min([Math]::Max($value, 0), 100)`                        |
| Case-sensitive containment check          | `$user -cin @('Alice','Bob')`                                     |
| Default value when input is blank         | `if ([string]::IsNullOrWhiteSpace($name)) { $name = 'Unknown' }` |
| Filter running services with name pattern | `Get-Service | Where-Object { $_.Status -eq 'Running' -and $_.Name -like 'SQL*' }` |
| Log and suppress noisy command output     | `Some-Command *>&1 >> log.txt`                                   |

As you read and write more PowerShell, you will start to recognize these patterns and invent your own, treating operators as a compact vocabulary for expressing intent.


